{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"\"a whole log simpler\" ... literally! Installation \u00b6 You can install this package via pip; pip install memo You might want to install extra dependencies depending on your use-case. pip install \"memo[web]\" What does this package do? \u00b6 This packages contains decorators that can help you route the input/output of functions to files/dataframes and other sources. It's useful in logging results from simulations or machine learning experiments. import numpy as np from memo import memfile @memfile ( filepath = \"results.jsonl\" ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 return { \"est_proba\" : np . mean ( n_uniq != class_size )} for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim ) The decorator ensures that all the keyword arguments and dictionary outputs of a function are logged. To see how it works in more detail, check the quickstart Tutorial \u00b6 There is a full course on this tool available on calmcode.io . This is the first video. Features \u00b6 This library also offers decorators to pipe to other sources. memlists sends the json blobs to a list memfile sends the json blobs to a file memweb sends the json blobs to a server via http-post requests memfunc sends the data to a callable that you supply, like print grid generates a convenient grid for your experiments random_grid generates a randomized grid for your experiments time_taken also logs the time the function takes to run We also offer an option to parallelize function calls using joblib. This is facilitated with a Runner class which supports multiple backends. Runner(backend=\"loky\") Runner(backend=\"threading\") Runner(backend=\"multiprocessing\")","title":"Home"},{"location":"index.html#installation","text":"You can install this package via pip; pip install memo You might want to install extra dependencies depending on your use-case. pip install \"memo[web]\"","title":"Installation"},{"location":"index.html#what-does-this-package-do","text":"This packages contains decorators that can help you route the input/output of functions to files/dataframes and other sources. It's useful in logging results from simulations or machine learning experiments. import numpy as np from memo import memfile @memfile ( filepath = \"results.jsonl\" ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 return { \"est_proba\" : np . mean ( n_uniq != class_size )} for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim ) The decorator ensures that all the keyword arguments and dictionary outputs of a function are logged. To see how it works in more detail, check the quickstart","title":"What does this package do?"},{"location":"index.html#tutorial","text":"There is a full course on this tool available on calmcode.io . This is the first video.","title":"Tutorial"},{"location":"index.html#features","text":"This library also offers decorators to pipe to other sources. memlists sends the json blobs to a list memfile sends the json blobs to a file memweb sends the json blobs to a server via http-post requests memfunc sends the data to a callable that you supply, like print grid generates a convenient grid for your experiments random_grid generates a randomized grid for your experiments time_taken also logs the time the function takes to run We also offer an option to parallelize function calls using joblib. This is facilitated with a Runner class which supports multiple backends. Runner(backend=\"loky\") Runner(backend=\"threading\") Runner(backend=\"multiprocessing\")","title":"Features"},{"location":"api.html","text":"Decorators that Capture Data \u00b6 memlist ( data ) \u00b6 Remembers input/output of a function in python list. Parameters: Name Type Description Default data List a list to push received data into required Example from memo import memlist data = [] @memlist ( data = data ) def simulate ( a , b ): return { \"result\" : a + b } # The `@memlist` decorator will allow the inputs/outputs to # be saved in the provided `data` list. for a in range ( 5 ): for b in range ( 10 ): simulate ( a = a , b = b ) assert len ( data ) == 50 # If we keep running more loops the list will grow. for a in range ( 6 , 10 + 1 ): for b in range ( 11 , 20 + 1 ): simulate ( a = a , b = b ) assert len ( data ) == 100 Source code in memo/_base.py def memlist ( data : List ): \"\"\" Remembers input/output of a function in python list. Arguments: data: a list to push received data into Example ```python from memo import memlist data = [] @memlist(data=data) def simulate(a, b): return {\"result\": a + b} # The `@memlist` decorator will allow the inputs/outputs to # be saved in the provided `data` list. for a in range(5): for b in range(10): simulate(a=a, b=b) assert len(data) == 50 # If we keep running more loops the list will grow. for a in range(6, 10 + 1): for b in range(11, 20 + 1): simulate(a=a, b=b) assert len(data) == 100 ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) data . append ({ ** kwargs , ** result }) return result return wrapper return decorator memfile ( filepath ) \u00b6 Remembers input/output of a function in a jsonl file on disk. Parameters: Name Type Description Default filepath str path to write data to required from memo import memfile @memfile ( filepath = \"tmpfile.jsonl\" ) def simulate ( a , b ): return { \"result\" : a + b } for a in range ( 5 ): for b in range ( 10 ): simulate ( a = a , b = b ) Source code in memo/_base.py def memfile ( filepath : str ): \"\"\" Remembers input/output of a function in a jsonl file on disk. Arguments: filepath: path to write data to ```python from memo import memfile @memfile(filepath=\"tmpfile.jsonl\") def simulate(a, b): return {\"result\": a + b} for a in range(5): for b in range(10): simulate(a=a, b=b) ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) with open ( filepath , \"a\" ) as f : ser = orjson . dumps ( { ** kwargs , ** result }, option = orjson . OPT_NAIVE_UTC | orjson . OPT_SERIALIZE_NUMPY , ) f . write ( ser . decode ( \"utf-8\" ) + \" \\n \" ) return result return wrapper return decorator memfunc ( callback ) \u00b6 Remembers input/output of a function by printing. Parameters: Name Type Description Default callback Callable callback function that receives a dictionary with logged info required from memo import memfunc , memlist data = [] @memlist ( data = data ) @memfunc ( callback = print ) def simulate ( a , b ): return { \"result\" : a + b } for a in range ( 5 ): for b in range ( 10 ): simulate ( a = a , b = b ) # You should now see print statements, and this holds: assert len ( data ) == 50 Source code in memo/_base.py def memfunc ( callback : Callable ): \"\"\" Remembers input/output of a function by printing. Arguments: callback: callback function that receives a dictionary with logged info ```python from memo import memfunc, memlist data = [] @memlist(data=data) @memfunc(callback=print) def simulate(a, b): return {\"result\": a + b} for a in range(5): for b in range(10): simulate(a=a, b=b) # You should now see print statements, and this holds: assert len(data) == 50 ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) callback ({ ** kwargs , ** result }) return result return wrapper return decorator memweb ( url ) \u00b6 Remembers input/output of a function by sending it over http to an endpoint. Important Note that this decorator requires an extra dependeny. Ensure it is installed properly by running either; python -m pip install \"memo[web]\" You can also install it by installing all optional dependencies. python -m pip install \"memo[all]\" Parameters: Name Type Description Default url str web url to post json to required Source code in memo/_http.py def memweb ( url : str ): \"\"\" Remembers input/output of a function by sending it over http to an endpoint. Important: Note that this decorator requires an extra dependeny. Ensure it is installed properly by running either; ``` python -m pip install \"memo[web]\" ``` You can also install it by installing all optional dependencies. ``` python -m pip install \"memo[all]\" ``` Arguments: url: web url to post json to \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) with httpx . Client () as client : _ = client . post ( url , data = { ** kwargs , ** result }) return result return wrapper return decorator","title":"Main"},{"location":"api.html#decorators-that-capture-data","text":"","title":"Decorators that Capture Data"},{"location":"api.html#memo._base.memlist","text":"Remembers input/output of a function in python list. Parameters: Name Type Description Default data List a list to push received data into required Example from memo import memlist data = [] @memlist ( data = data ) def simulate ( a , b ): return { \"result\" : a + b } # The `@memlist` decorator will allow the inputs/outputs to # be saved in the provided `data` list. for a in range ( 5 ): for b in range ( 10 ): simulate ( a = a , b = b ) assert len ( data ) == 50 # If we keep running more loops the list will grow. for a in range ( 6 , 10 + 1 ): for b in range ( 11 , 20 + 1 ): simulate ( a = a , b = b ) assert len ( data ) == 100 Source code in memo/_base.py def memlist ( data : List ): \"\"\" Remembers input/output of a function in python list. Arguments: data: a list to push received data into Example ```python from memo import memlist data = [] @memlist(data=data) def simulate(a, b): return {\"result\": a + b} # The `@memlist` decorator will allow the inputs/outputs to # be saved in the provided `data` list. for a in range(5): for b in range(10): simulate(a=a, b=b) assert len(data) == 50 # If we keep running more loops the list will grow. for a in range(6, 10 + 1): for b in range(11, 20 + 1): simulate(a=a, b=b) assert len(data) == 100 ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) data . append ({ ** kwargs , ** result }) return result return wrapper return decorator","title":"memlist()"},{"location":"api.html#memo._base.memfile","text":"Remembers input/output of a function in a jsonl file on disk. Parameters: Name Type Description Default filepath str path to write data to required from memo import memfile @memfile ( filepath = \"tmpfile.jsonl\" ) def simulate ( a , b ): return { \"result\" : a + b } for a in range ( 5 ): for b in range ( 10 ): simulate ( a = a , b = b ) Source code in memo/_base.py def memfile ( filepath : str ): \"\"\" Remembers input/output of a function in a jsonl file on disk. Arguments: filepath: path to write data to ```python from memo import memfile @memfile(filepath=\"tmpfile.jsonl\") def simulate(a, b): return {\"result\": a + b} for a in range(5): for b in range(10): simulate(a=a, b=b) ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) with open ( filepath , \"a\" ) as f : ser = orjson . dumps ( { ** kwargs , ** result }, option = orjson . OPT_NAIVE_UTC | orjson . OPT_SERIALIZE_NUMPY , ) f . write ( ser . decode ( \"utf-8\" ) + \" \\n \" ) return result return wrapper return decorator","title":"memfile()"},{"location":"api.html#memo._base.memfunc","text":"Remembers input/output of a function by printing. Parameters: Name Type Description Default callback Callable callback function that receives a dictionary with logged info required from memo import memfunc , memlist data = [] @memlist ( data = data ) @memfunc ( callback = print ) def simulate ( a , b ): return { \"result\" : a + b } for a in range ( 5 ): for b in range ( 10 ): simulate ( a = a , b = b ) # You should now see print statements, and this holds: assert len ( data ) == 50 Source code in memo/_base.py def memfunc ( callback : Callable ): \"\"\" Remembers input/output of a function by printing. Arguments: callback: callback function that receives a dictionary with logged info ```python from memo import memfunc, memlist data = [] @memlist(data=data) @memfunc(callback=print) def simulate(a, b): return {\"result\": a + b} for a in range(5): for b in range(10): simulate(a=a, b=b) # You should now see print statements, and this holds: assert len(data) == 50 ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) callback ({ ** kwargs , ** result }) return result return wrapper return decorator","title":"memfunc()"},{"location":"api.html#memo._http.memweb","text":"Remembers input/output of a function by sending it over http to an endpoint. Important Note that this decorator requires an extra dependeny. Ensure it is installed properly by running either; python -m pip install \"memo[web]\" You can also install it by installing all optional dependencies. python -m pip install \"memo[all]\" Parameters: Name Type Description Default url str web url to post json to required Source code in memo/_http.py def memweb ( url : str ): \"\"\" Remembers input/output of a function by sending it over http to an endpoint. Important: Note that this decorator requires an extra dependeny. Ensure it is installed properly by running either; ``` python -m pip install \"memo[web]\" ``` You can also install it by installing all optional dependencies. ``` python -m pip install \"memo[all]\" ``` Arguments: url: web url to post json to \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) with httpx . Client () as client : _ = client . post ( url , data = { ** kwargs , ** result }) return result return wrapper return decorator","title":"memweb()"},{"location":"faq.html","text":"Do I really need to output a dictionary? \u00b6 It's an opinionated packages but we think it's neater that way. You'll usually want to have a name attached to column names in a dataframe and functions can have multiple outputs. Can I add a progress bar? \u00b6 You get a progress bar if you're using a Runner Demo \u00b6 import numpy as np from memo import memlist , memfile , grid , time_taken , Runner data = [] @memfile ( filepath = \"results.jsonl\" ) @memlist ( data = data ) @time_taken () def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } settings = grid ( class_size = range ( 20 , 30 ), n_sim = [ 100 , 10_000 , 1_000_000 ]) # This runner comes with a progress bar runner = Runner ( backend = \"threading\" , n_jobs = 1 ) runner . run ( func = birthday_experiment , settings = settings ) Can I get amazing visualisations? \u00b6 Sure, but they won't be supplied by this package. Instead we might recommend checking out hiplot . It gives a pretty parallel coordinates from jupyter notebook. If you've got a list with dictionaries you can run; import hiplot as hip data = [{ 'dropout' : 0.1 , 'lr' : 0.001 , 'loss' : 10.0 , 'optimizer' : 'SGD' }, { 'dropout' : 0.15 , 'lr' : 0.01 , 'loss' : 3.5 , 'optimizer' : 'Adam' }, { 'dropout' : 0.3 , 'lr' : 0.1 , 'loss' : 4.5 , 'optimizer' : 'Adam' }] hip . Experiment . from_iterable ( data ) . display () You can read in a file locally as well. import pandas as pd import hiplot as hip df = pd . read_json ( \"collected-data.jsonl\" , lines = True ) data = df . to_dict ( orient = 'records' ) hip . Experiment . from_iterable ( data ) . display ()","title":"FAQ"},{"location":"faq.html#do-i-really-need-to-output-a-dictionary","text":"It's an opinionated packages but we think it's neater that way. You'll usually want to have a name attached to column names in a dataframe and functions can have multiple outputs.","title":"Do I really need to output a dictionary?"},{"location":"faq.html#can-i-add-a-progress-bar","text":"You get a progress bar if you're using a Runner","title":"Can I add a progress bar?"},{"location":"faq.html#demo","text":"import numpy as np from memo import memlist , memfile , grid , time_taken , Runner data = [] @memfile ( filepath = \"results.jsonl\" ) @memlist ( data = data ) @time_taken () def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } settings = grid ( class_size = range ( 20 , 30 ), n_sim = [ 100 , 10_000 , 1_000_000 ]) # This runner comes with a progress bar runner = Runner ( backend = \"threading\" , n_jobs = 1 ) runner . run ( func = birthday_experiment , settings = settings )","title":"Demo"},{"location":"faq.html#can-i-get-amazing-visualisations","text":"Sure, but they won't be supplied by this package. Instead we might recommend checking out hiplot . It gives a pretty parallel coordinates from jupyter notebook. If you've got a list with dictionaries you can run; import hiplot as hip data = [{ 'dropout' : 0.1 , 'lr' : 0.001 , 'loss' : 10.0 , 'optimizer' : 'SGD' }, { 'dropout' : 0.15 , 'lr' : 0.01 , 'loss' : 3.5 , 'optimizer' : 'Adam' }, { 'dropout' : 0.3 , 'lr' : 0.1 , 'loss' : 4.5 , 'optimizer' : 'Adam' }] hip . Experiment . from_iterable ( data ) . display () You can read in a file locally as well. import pandas as pd import hiplot as hip df = pd . read_json ( \"collected-data.jsonl\" , lines = True ) data = df . to_dict ( orient = 'records' ) hip . Experiment . from_iterable ( data ) . display ()","title":"Can I get amazing visualisations?"},{"location":"getting-started.html","text":"Base Scenario \u00b6 Let's say you're running a simulation, or maybe a machine learning experiment. Then you might have code that looks like this; import numpy as np def birthday_experiment ( class_size , n_sim = 10_000 ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 return np . mean ( n_uniq != class_size ) results = [ birthday_experiment ( s ) for s in range ( 2 , 40 )] This example sort of works, but how would we now go about plotting our results? If you want to plot the effect of class_size and the simulated probability then it'd be do-able. But things get tricky if you're also interested in seeing the effect of n_sim as well. The input of the simulation isn't nicely captured together with the output of the simulation. Decorators \u00b6 The idea behind this library is that you can rewrite this function, only slightly, to make all of this data collection a whole log simpler. import numpy as np from memo import memlist data = [] @memlist ( data = data ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 return { \"est_proba\" : np . mean ( n_uniq != class_size )} for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim ) The data object now represents a list of dictionaries that have \"n_sim\" , \"class_size\" and \"est_proba\" as keys. You can easily turn these into a pandas DataFrame if you'd like via pd.DataFrame(data) . Logging More \u00b6 The memlist decorate takes care of all data collection. It captures all keyword arguments of the function as well as the dictionary output of the function. This then is appended this to a list data . Especially when you're iteration on your experiments this might turn out to be a lovely pattern. For example, suppose we also want to log how long the simulation takes; import time import numpy as np from memo import memlist data = [] @memlist ( data = data ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" t1 = time . time () sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) t2 = time . time () return { \"est_proba\" : proba , \"time\" : t2 - t1 } for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim ) Power \u00b6 The real power of the library is that you can choose not only to log to a list. You can just as easily write to a file too! import time import numpy as np from memo import memlist , memfile data = [] @memfile ( filepath = \"results.json\" ) @memlist ( data = data ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" t1 = time . time () sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) t2 = time . time () return { \"est_proba\" : proba , \"time\" : t2 - t1 } for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim ) Utilities \u00b6 The library also offers utilities to make the creation of these grids even easier. In particular; We supply a grid generation mechanism to prevent a lot of for-loops. We supply a @capture_time so that you don't need to write that logic yourself. import numpy as np from memo import memlist , memfile , grid , time_taken data = [] @memfile ( filepath = \"results.json\" ) @memlist ( data = data ) @time_taken () def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } for settings in grid ( class_size = range ( 2 , 40 ), n_sim = [ 1000 , 10000 , 100000 ]): birthday_experiment ( ** settings ) Parallel \u00b6 If you have a lot of simulations you'd like to run, it might be helpful to run them in parallel. That's why this library also hosts a Runner class that can run your functions on multiple CPU cores. import numpy as np from memo import memlist , memfile , grid , time_taken , Runner data = [] @memfile ( filepath = \"results.jsonl\" ) @memlist ( data = data ) @time_taken () def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } settings = grid ( class_size = range ( 20 , 30 ), n_sim = [ 100 , 10_000 , 1_000_000 ]) # To Run in parallel runner = Runner ( backend = \"threading\" , n_jobs = 1 ) runner . run ( func = birthday_experiment , settings = settings ) More features \u00b6 These decorators aren't performing magic, but my experience has been that these decorators make it more fun to actually log the results of experiments. It's nice to be able to just add a decorator to a function and not have to worry about logging the statistics. The library also offers extra features to make things a whole log simpler. memweb sends the json blobs to a server via http-post requests memfunc sends the data to a callable that you supply, like print random_grid generates a randomized grid for your experiments","title":"Getting Started"},{"location":"getting-started.html#base-scenario","text":"Let's say you're running a simulation, or maybe a machine learning experiment. Then you might have code that looks like this; import numpy as np def birthday_experiment ( class_size , n_sim = 10_000 ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 return np . mean ( n_uniq != class_size ) results = [ birthday_experiment ( s ) for s in range ( 2 , 40 )] This example sort of works, but how would we now go about plotting our results? If you want to plot the effect of class_size and the simulated probability then it'd be do-able. But things get tricky if you're also interested in seeing the effect of n_sim as well. The input of the simulation isn't nicely captured together with the output of the simulation.","title":"Base Scenario"},{"location":"getting-started.html#decorators","text":"The idea behind this library is that you can rewrite this function, only slightly, to make all of this data collection a whole log simpler. import numpy as np from memo import memlist data = [] @memlist ( data = data ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 return { \"est_proba\" : np . mean ( n_uniq != class_size )} for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim ) The data object now represents a list of dictionaries that have \"n_sim\" , \"class_size\" and \"est_proba\" as keys. You can easily turn these into a pandas DataFrame if you'd like via pd.DataFrame(data) .","title":"Decorators"},{"location":"getting-started.html#logging-more","text":"The memlist decorate takes care of all data collection. It captures all keyword arguments of the function as well as the dictionary output of the function. This then is appended this to a list data . Especially when you're iteration on your experiments this might turn out to be a lovely pattern. For example, suppose we also want to log how long the simulation takes; import time import numpy as np from memo import memlist data = [] @memlist ( data = data ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" t1 = time . time () sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) t2 = time . time () return { \"est_proba\" : proba , \"time\" : t2 - t1 } for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim )","title":"Logging More"},{"location":"getting-started.html#power","text":"The real power of the library is that you can choose not only to log to a list. You can just as easily write to a file too! import time import numpy as np from memo import memlist , memfile data = [] @memfile ( filepath = \"results.json\" ) @memlist ( data = data ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" t1 = time . time () sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) t2 = time . time () return { \"est_proba\" : proba , \"time\" : t2 - t1 } for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim )","title":"Power"},{"location":"getting-started.html#utilities","text":"The library also offers utilities to make the creation of these grids even easier. In particular; We supply a grid generation mechanism to prevent a lot of for-loops. We supply a @capture_time so that you don't need to write that logic yourself. import numpy as np from memo import memlist , memfile , grid , time_taken data = [] @memfile ( filepath = \"results.json\" ) @memlist ( data = data ) @time_taken () def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } for settings in grid ( class_size = range ( 2 , 40 ), n_sim = [ 1000 , 10000 , 100000 ]): birthday_experiment ( ** settings )","title":"Utilities"},{"location":"getting-started.html#parallel","text":"If you have a lot of simulations you'd like to run, it might be helpful to run them in parallel. That's why this library also hosts a Runner class that can run your functions on multiple CPU cores. import numpy as np from memo import memlist , memfile , grid , time_taken , Runner data = [] @memfile ( filepath = \"results.jsonl\" ) @memlist ( data = data ) @time_taken () def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } settings = grid ( class_size = range ( 20 , 30 ), n_sim = [ 100 , 10_000 , 1_000_000 ]) # To Run in parallel runner = Runner ( backend = \"threading\" , n_jobs = 1 ) runner . run ( func = birthday_experiment , settings = settings )","title":"Parallel"},{"location":"getting-started.html#more-features","text":"These decorators aren't performing magic, but my experience has been that these decorators make it more fun to actually log the results of experiments. It's nice to be able to just add a decorator to a function and not have to worry about logging the statistics. The library also offers extra features to make things a whole log simpler. memweb sends the json blobs to a server via http-post requests memfunc sends the data to a callable that you supply, like print random_grid generates a randomized grid for your experiments","title":"More features"},{"location":"runner.html","text":"Runner \u00b6 Run functions in parallel with joblib. Parameters: Name Type Description Default backend choice of parallism backend, can be \"loky\", \"multiprocessing\" or \"threading\" required n_jobs degree of parallism, set to -1 to use all available cores required All keyword arguments during instantiaition will pass through to parallel_backend . More information on joblib can be found here . Joblib can also attach to third party backends such as Ray or Apache spark, however that functionality has not yet been tested. Usage: from memo import Runner runner = Runner ( backend = 'threading' , n_jobs = 2 ) run ( self , func , settings , progbar = True ) \u00b6 Run function with joblibs parallel backend Parameters: Name Type Description Default func Callable The function to be run in parallel. required settings Iterable[Dict] An Iterable of Key-value pairs. required progbar bool Show progress bar. Defaults to True. True Exceptions: Type Description TypeError When **kwargs doesn't match signature of parallel_backend Usage: from memo import Runner import numpy as np from memo import memlist , grid , time_taken data = [] @memlist ( data = data ) @time_taken () def birthday_experiment ( class_size , n_sim ): sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } settings = grid ( class_size = range ( 20 , 30 ), n_sim = [ 100 , 10_000 ], progbar = False ) # To Run in parallel runner = Runner ( backend = \"threading\" , n_jobs =- 1 ) runner . run ( func = birthday_experiment , settings = settings ) Source code in memo/_runner.py def run ( self , func : Callable , settings : Iterable [ Dict ], progbar : bool = True ) -> None : \"\"\"Run function with joblibs parallel backend Args: func (Callable): The function to be run in parallel. settings (Iterable): An Iterable of Key-value pairs. progbar (bool, optional): Show progress bar. Defaults to True. Raises: TypeError: When **kwargs doesn't match signature of `parallel_backend` Usage: ```python from memo import Runner import numpy as np from memo import memlist, grid, time_taken data = [] @memlist(data=data) @time_taken() def birthday_experiment(class_size, n_sim): sims = np.random.randint(1, 365 + 1, (n_sim, class_size)) sort_sims = np.sort(sims, axis=1) n_uniq = (sort_sims[:, 1:] != sort_sims[:, :-1]).sum(axis=1) + 1 proba = np.mean(n_uniq != class_size) return {\"est_proba\": proba} settings = grid(class_size=range(20, 30), n_sim=[100, 10_000], progbar=False) # To Run in parallel runner = Runner(backend=\"threading\", n_jobs=-1) runner.run(func=birthday_experiment, settings=settings) ``` \"\"\" if not isinstance ( settings , ( list , tuple , set , GeneratorType ) ): # check settings is iterable raise TypeError ( f \"Type { type ( settings ) } not supported\" ) elif progbar and not isinstance ( settings , GeneratorType ): total = len ( settings ) with Progress () as progress : task = progress . add_task ( \"[red]Runner....\" , total = total ) class BatchCompletionCallBack ( object ): def __init__ ( self , dispatch_timestamp , batch_size , parallel ): self . dispatch_timestamp = dispatch_timestamp self . batch_size = batch_size self . parallel = parallel def __call__ ( self , out ): self . parallel . n_completed_tasks += self . batch_size this_batch_duration = time . time () - self . dispatch_timestamp self . parallel . _backend . batch_completed ( self . batch_size , this_batch_duration ) self . parallel . print_progress () # Update progress bar progress . update ( task , completed = self . parallel . n_completed_tasks , refresh = True , ) with self . parallel . _lock : if self . parallel . _original_iterator is not None : self . parallel . dispatch_next () # Monkey patch joblib . parallel . BatchCompletionCallBack = BatchCompletionCallBack self . _run ( func , settings ) else : if isinstance ( settings , GeneratorType ): warnings . warn ( \"Progress bar not supported for generator settings\" ) self . _run ( func , settings )","title":"Runner"},{"location":"runner.html#memo._runner.Runner","text":"Run functions in parallel with joblib. Parameters: Name Type Description Default backend choice of parallism backend, can be \"loky\", \"multiprocessing\" or \"threading\" required n_jobs degree of parallism, set to -1 to use all available cores required All keyword arguments during instantiaition will pass through to parallel_backend . More information on joblib can be found here . Joblib can also attach to third party backends such as Ray or Apache spark, however that functionality has not yet been tested. Usage: from memo import Runner runner = Runner ( backend = 'threading' , n_jobs = 2 )","title":"Runner"},{"location":"runner.html#memo._runner.Runner.run","text":"Run function with joblibs parallel backend Parameters: Name Type Description Default func Callable The function to be run in parallel. required settings Iterable[Dict] An Iterable of Key-value pairs. required progbar bool Show progress bar. Defaults to True. True Exceptions: Type Description TypeError When **kwargs doesn't match signature of parallel_backend Usage: from memo import Runner import numpy as np from memo import memlist , grid , time_taken data = [] @memlist ( data = data ) @time_taken () def birthday_experiment ( class_size , n_sim ): sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } settings = grid ( class_size = range ( 20 , 30 ), n_sim = [ 100 , 10_000 ], progbar = False ) # To Run in parallel runner = Runner ( backend = \"threading\" , n_jobs =- 1 ) runner . run ( func = birthday_experiment , settings = settings ) Source code in memo/_runner.py def run ( self , func : Callable , settings : Iterable [ Dict ], progbar : bool = True ) -> None : \"\"\"Run function with joblibs parallel backend Args: func (Callable): The function to be run in parallel. settings (Iterable): An Iterable of Key-value pairs. progbar (bool, optional): Show progress bar. Defaults to True. Raises: TypeError: When **kwargs doesn't match signature of `parallel_backend` Usage: ```python from memo import Runner import numpy as np from memo import memlist, grid, time_taken data = [] @memlist(data=data) @time_taken() def birthday_experiment(class_size, n_sim): sims = np.random.randint(1, 365 + 1, (n_sim, class_size)) sort_sims = np.sort(sims, axis=1) n_uniq = (sort_sims[:, 1:] != sort_sims[:, :-1]).sum(axis=1) + 1 proba = np.mean(n_uniq != class_size) return {\"est_proba\": proba} settings = grid(class_size=range(20, 30), n_sim=[100, 10_000], progbar=False) # To Run in parallel runner = Runner(backend=\"threading\", n_jobs=-1) runner.run(func=birthday_experiment, settings=settings) ``` \"\"\" if not isinstance ( settings , ( list , tuple , set , GeneratorType ) ): # check settings is iterable raise TypeError ( f \"Type { type ( settings ) } not supported\" ) elif progbar and not isinstance ( settings , GeneratorType ): total = len ( settings ) with Progress () as progress : task = progress . add_task ( \"[red]Runner....\" , total = total ) class BatchCompletionCallBack ( object ): def __init__ ( self , dispatch_timestamp , batch_size , parallel ): self . dispatch_timestamp = dispatch_timestamp self . batch_size = batch_size self . parallel = parallel def __call__ ( self , out ): self . parallel . n_completed_tasks += self . batch_size this_batch_duration = time . time () - self . dispatch_timestamp self . parallel . _backend . batch_completed ( self . batch_size , this_batch_duration ) self . parallel . print_progress () # Update progress bar progress . update ( task , completed = self . parallel . n_completed_tasks , refresh = True , ) with self . parallel . _lock : if self . parallel . _original_iterator is not None : self . parallel . dispatch_next () # Monkey patch joblib . parallel . BatchCompletionCallBack = BatchCompletionCallBack self . _run ( func , settings ) else : if isinstance ( settings , GeneratorType ): warnings . warn ( \"Progress bar not supported for generator settings\" ) self . _run ( func , settings )","title":"run()"},{"location":"util.html","text":"Utility Methods \u00b6 grid ( shuffle = True , progbar = None , ** kwargs ) \u00b6 Generates a grid of settings. Parameters: Name Type Description Default kwargs the name of parameter is the key while the values represent items to iterate over {} Example from memo import grid settings = grid ( a = [ 1 , 2 ], b = [ 1 , 2 ], shuffle = False ) expected = [ { 'a' : 1 , 'b' : 1 }, { 'a' : 1 , 'b' : 2 }, { 'a' : 2 , 'b' : 1 }, { 'a' : 2 , 'b' : 2 } ] assert settings == expected Source code in memo/_grid.py def grid ( shuffle = True , progbar = None , ** kwargs ): \"\"\" Generates a grid of settings. Arguments: kwargs: the name of parameter is the key while the values represent items to iterate over Example ```python from memo import grid settings = grid(a=[1,2], b=[1, 2], shuffle=False) expected = [ {'a': 1, 'b': 1}, {'a': 1, 'b': 2}, {'a': 2, 'b': 1}, {'a': 2, 'b': 2} ] assert settings == expected ``` \"\"\" settings = [ dict ( zip ( kwargs . keys (), d )) for d in it . product ( * [ v for v in kwargs . values ()]) ] if progbar : raise DeprecationWarning ( \"`progbar` is deprecated, use a `from memo import Runner` to get a progbar.\" ) if shuffle : random . shuffle ( settings ) return settings random_grid ( n = 30 , ** kwargs ) \u00b6 Generates a random grid settings. Parameters: Name Type Description Default kwargs the name of parameter is the key while the values represent items to iterate over {} Example from memo import random_grid settings = random_grid ( n = 30 , a = [ 1 , 2 ], b = [ 1 , 2 ]) assert len ( settings ) == 30 Source code in memo/_grid.py def random_grid ( n = 30 , ** kwargs ): \"\"\" Generates a random grid settings. Arguments: kwargs: the name of parameter is the key while the values represent items to iterate over Example ```python from memo import random_grid settings = random_grid(n=30, a=[1,2], b=[1, 2]) assert len(settings) == 30 ``` \"\"\" return [{ k : random . choice ( v ) for k , v in kwargs . items ()} for _ in range ( n )] time_taken ( minutes = False , rounding = 2 ) \u00b6 Adds additional time-based information to output. Parameters: Name Type Description Default minutes log minutes instead of seconds False rounding number of decimals to round the timing to 2 Examples: import numpy as np from memo import memlist , grid , time_taken data = [] @memlist ( data = data ) @time_taken () def birthday_experiment ( class_size , n_sim ): sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } settings = grid ( class_size = range ( 5 , 50 ), n_sim = [ 100 , 10_000 , 1_000_000 ]) for setting in settings : birthday_experiment ( ** setting ) Source code in memo/_util.py def time_taken ( minutes = False , rounding = 2 ): \"\"\" Adds additional time-based information to output. Arguments: minutes: log minutes instead of seconds rounding: number of decimals to round the timing to Example: ```python import numpy as np from memo import memlist, grid, time_taken data = [] @memlist(data=data) @time_taken() def birthday_experiment(class_size, n_sim): sims = np.random.randint(1, 365 + 1, (n_sim, class_size)) sort_sims = np.sort(sims, axis=1) n_uniq = (sort_sims[:, 1:] != sort_sims[:, :-1]).sum(axis = 1) + 1 proba = np.mean(n_uniq != class_size) return {\"est_proba\": proba} settings = grid(class_size=range(5, 50), n_sim=[100, 10_000, 1_000_000]) for setting in settings: birthday_experiment(**setting) ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): tic = time . time () result = func ( * args , ** kwargs ) toc = time . time () time_total = toc - tic if minutes : time_total = time_total / 60 result = { ** result , \"time_taken\" : round ( time_total , rounding )} return result return wrapper return decorator","title":"Utility"},{"location":"util.html#utility-methods","text":"","title":"Utility Methods"},{"location":"util.html#memo._grid.grid","text":"Generates a grid of settings. Parameters: Name Type Description Default kwargs the name of parameter is the key while the values represent items to iterate over {} Example from memo import grid settings = grid ( a = [ 1 , 2 ], b = [ 1 , 2 ], shuffle = False ) expected = [ { 'a' : 1 , 'b' : 1 }, { 'a' : 1 , 'b' : 2 }, { 'a' : 2 , 'b' : 1 }, { 'a' : 2 , 'b' : 2 } ] assert settings == expected Source code in memo/_grid.py def grid ( shuffle = True , progbar = None , ** kwargs ): \"\"\" Generates a grid of settings. Arguments: kwargs: the name of parameter is the key while the values represent items to iterate over Example ```python from memo import grid settings = grid(a=[1,2], b=[1, 2], shuffle=False) expected = [ {'a': 1, 'b': 1}, {'a': 1, 'b': 2}, {'a': 2, 'b': 1}, {'a': 2, 'b': 2} ] assert settings == expected ``` \"\"\" settings = [ dict ( zip ( kwargs . keys (), d )) for d in it . product ( * [ v for v in kwargs . values ()]) ] if progbar : raise DeprecationWarning ( \"`progbar` is deprecated, use a `from memo import Runner` to get a progbar.\" ) if shuffle : random . shuffle ( settings ) return settings","title":"grid()"},{"location":"util.html#memo._grid.random_grid","text":"Generates a random grid settings. Parameters: Name Type Description Default kwargs the name of parameter is the key while the values represent items to iterate over {} Example from memo import random_grid settings = random_grid ( n = 30 , a = [ 1 , 2 ], b = [ 1 , 2 ]) assert len ( settings ) == 30 Source code in memo/_grid.py def random_grid ( n = 30 , ** kwargs ): \"\"\" Generates a random grid settings. Arguments: kwargs: the name of parameter is the key while the values represent items to iterate over Example ```python from memo import random_grid settings = random_grid(n=30, a=[1,2], b=[1, 2]) assert len(settings) == 30 ``` \"\"\" return [{ k : random . choice ( v ) for k , v in kwargs . items ()} for _ in range ( n )]","title":"random_grid()"},{"location":"util.html#memo._util.time_taken","text":"Adds additional time-based information to output. Parameters: Name Type Description Default minutes log minutes instead of seconds False rounding number of decimals to round the timing to 2 Examples: import numpy as np from memo import memlist , grid , time_taken data = [] @memlist ( data = data ) @time_taken () def birthday_experiment ( class_size , n_sim ): sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } settings = grid ( class_size = range ( 5 , 50 ), n_sim = [ 100 , 10_000 , 1_000_000 ]) for setting in settings : birthday_experiment ( ** setting ) Source code in memo/_util.py def time_taken ( minutes = False , rounding = 2 ): \"\"\" Adds additional time-based information to output. Arguments: minutes: log minutes instead of seconds rounding: number of decimals to round the timing to Example: ```python import numpy as np from memo import memlist, grid, time_taken data = [] @memlist(data=data) @time_taken() def birthday_experiment(class_size, n_sim): sims = np.random.randint(1, 365 + 1, (n_sim, class_size)) sort_sims = np.sort(sims, axis=1) n_uniq = (sort_sims[:, 1:] != sort_sims[:, :-1]).sum(axis = 1) + 1 proba = np.mean(n_uniq != class_size) return {\"est_proba\": proba} settings = grid(class_size=range(5, 50), n_sim=[100, 10_000, 1_000_000]) for setting in settings: birthday_experiment(**setting) ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): tic = time . time () result = func ( * args , ** kwargs ) toc = time . time () time_total = toc - tic if minutes : time_total = time_total / 60 result = { ** result , \"time_taken\" : round ( time_total , rounding )} return result return wrapper return decorator","title":"time_taken()"}]}