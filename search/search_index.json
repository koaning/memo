{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"\"a whole log simpler\" ... literally! Installation \u00b6 You can install this package via pip; pip install memo You might want to install extra dependencies depending on your use-case. pip install \"memo[web]\" What does this package do? \u00b6 This packages contains decorators that can help you route the input/output of functions to files/dataframes and other sources. It's useful in logging results from simulations or machine learning experiments. import numpy as np from memo import memfile @memfile ( filepath = \"results.jsonl\" ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 return { \"est_proba\" : np . mean ( n_uniq != class_size )} for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim ) The decorator ensures that all the keyword arguments and dictionary outputs of a function are logged. To see how it works in more detail, check the quickstart Tutorial \u00b6 There is a full course on this tool available on calmcode.io . This is the first video. Features \u00b6 This library also offers decorators to pipe to other sources. memlists sends the json blobs to a list memfile sends the json blobs to a file memweb sends the json blobs to a server via http-post requests memfunc sends the data to a callable that you supply, like print grid generates a convenient grid for your experiments random_grid generates a randomized grid for your experiments time_taken also logs the time the function takes to run","title":"Home"},{"location":"index.html#installation","text":"You can install this package via pip; pip install memo You might want to install extra dependencies depending on your use-case. pip install \"memo[web]\"","title":"Installation"},{"location":"index.html#what-does-this-package-do","text":"This packages contains decorators that can help you route the input/output of functions to files/dataframes and other sources. It's useful in logging results from simulations or machine learning experiments. import numpy as np from memo import memfile @memfile ( filepath = \"results.jsonl\" ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 return { \"est_proba\" : np . mean ( n_uniq != class_size )} for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim ) The decorator ensures that all the keyword arguments and dictionary outputs of a function are logged. To see how it works in more detail, check the quickstart","title":"What does this package do?"},{"location":"index.html#tutorial","text":"There is a full course on this tool available on calmcode.io . This is the first video.","title":"Tutorial"},{"location":"index.html#features","text":"This library also offers decorators to pipe to other sources. memlists sends the json blobs to a list memfile sends the json blobs to a file memweb sends the json blobs to a server via http-post requests memfunc sends the data to a callable that you supply, like print grid generates a convenient grid for your experiments random_grid generates a randomized grid for your experiments time_taken also logs the time the function takes to run","title":"Features"},{"location":"api.html","text":"Decorators that Capture Data \u00b6 memlist ( data ) \u00b6 Remembers input/output of a function in python list. Parameters: Name Type Description Default data List a list to push received data into required Example from memo import memlist data = [] @memlist ( data = data ) def simulate ( a , b ): return { \"result\" : a + b } # The `@memlist` decorator will allow the inputs/outputs to # be saved in the provided `data` list. for a in range ( 5 ): for b in range ( 10 ): simulate ( a = a , b = b ) assert len ( data ) == 50 # If we keep running more loops the list will grow. for a in range ( 6 , 10 + 1 ): for b in range ( 11 , 20 + 1 ): simulate ( a = a , b = b ) assert len ( data ) == 100 Source code in memo/_base.py def memlist ( data : List ): \"\"\" Remembers input/output of a function in python list. Arguments: data: a list to push received data into Example ```python from memo import memlist data = [] @memlist(data=data) def simulate(a, b): return {\"result\": a + b} # The `@memlist` decorator will allow the inputs/outputs to # be saved in the provided `data` list. for a in range(5): for b in range(10): simulate(a=a, b=b) assert len(data) == 50 # If we keep running more loops the list will grow. for a in range(6, 10 + 1): for b in range(11, 20 + 1): simulate(a=a, b=b) assert len(data) == 100 ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) data . append ({ ** kwargs , ** result }) return result return wrapper return decorator memfile ( filepath ) \u00b6 Remembers input/output of a function in a jsonl file on disk. Parameters: Name Type Description Default filepath str path to write data to required from memo import memfile @memfile ( filepath = \"tmpfile.jsonl\" ) def simulate ( a , b ): return { \"result\" : a + b } for a in range ( 5 ): for b in range ( 10 ): simulate ( a = a , b = b ) Source code in memo/_base.py def memfile ( filepath : str ): \"\"\" Remembers input/output of a function in a jsonl file on disk. Arguments: filepath: path to write data to ```python from memo import memfile @memfile(filepath=\"tmpfile.jsonl\") def simulate(a, b): return {\"result\": a + b} for a in range(5): for b in range(10): simulate(a=a, b=b) ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) with open ( filepath , \"a\" ) as f : ser = orjson . dumps ( { ** kwargs , ** result }, option = orjson . OPT_NAIVE_UTC | orjson . OPT_SERIALIZE_NUMPY , ) f . write ( ser . decode ( \"utf-8\" ) + \" \\n \" ) return result return wrapper return decorator memfunc ( callback ) \u00b6 Remembers input/output of a function by printing. Parameters: Name Type Description Default callback Callable callback function that receives a dictionary with logged info required from memo import memfunc , memlist data = [] @memlist ( data = data ) @memfunc ( callback = print ) def simulate ( a , b ): return { \"result\" : a + b } for a in range ( 5 ): for b in range ( 10 ): simulate ( a = a , b = b ) # You should now see print statements, and this holds: assert len ( data ) == 50 Source code in memo/_base.py def memfunc ( callback : Callable ): \"\"\" Remembers input/output of a function by printing. Arguments: callback: callback function that receives a dictionary with logged info ```python from memo import memfunc, memlist data = [] @memlist(data=data) @memfunc(callback=print) def simulate(a, b): return {\"result\": a + b} for a in range(5): for b in range(10): simulate(a=a, b=b) # You should now see print statements, and this holds: assert len(data) == 50 ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) callback ({ ** kwargs , ** result }) return result return wrapper return decorator memweb ( url ) \u00b6 Remembers input/output of a function by sending it over http to an endpoint. Important Note that this decorator requires an extra dependeny. Ensure it is installed properly by running either; python -m pip install \"memo[web]\" You can also install it by installing all optional dependencies. python -m pip install \"memo[all]\" Parameters: Name Type Description Default url str web url to post json to required Source code in memo/_http.py def memweb ( url : str ): \"\"\" Remembers input/output of a function by sending it over http to an endpoint. Important: Note that this decorator requires an extra dependeny. Ensure it is installed properly by running either; ``` python -m pip install \"memo[web]\" ``` You can also install it by installing all optional dependencies. ``` python -m pip install \"memo[all]\" ``` Arguments: url: web url to post json to \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) with httpx . Client () as client : _ = client . post ( url , data = { ** kwargs , ** result }) return result return wrapper return decorator","title":"Main"},{"location":"api.html#decorators-that-capture-data","text":"","title":"Decorators that Capture Data"},{"location":"api.html#memo._base.memlist","text":"Remembers input/output of a function in python list. Parameters: Name Type Description Default data List a list to push received data into required Example from memo import memlist data = [] @memlist ( data = data ) def simulate ( a , b ): return { \"result\" : a + b } # The `@memlist` decorator will allow the inputs/outputs to # be saved in the provided `data` list. for a in range ( 5 ): for b in range ( 10 ): simulate ( a = a , b = b ) assert len ( data ) == 50 # If we keep running more loops the list will grow. for a in range ( 6 , 10 + 1 ): for b in range ( 11 , 20 + 1 ): simulate ( a = a , b = b ) assert len ( data ) == 100 Source code in memo/_base.py def memlist ( data : List ): \"\"\" Remembers input/output of a function in python list. Arguments: data: a list to push received data into Example ```python from memo import memlist data = [] @memlist(data=data) def simulate(a, b): return {\"result\": a + b} # The `@memlist` decorator will allow the inputs/outputs to # be saved in the provided `data` list. for a in range(5): for b in range(10): simulate(a=a, b=b) assert len(data) == 50 # If we keep running more loops the list will grow. for a in range(6, 10 + 1): for b in range(11, 20 + 1): simulate(a=a, b=b) assert len(data) == 100 ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) data . append ({ ** kwargs , ** result }) return result return wrapper return decorator","title":"memlist()"},{"location":"api.html#memo._base.memfile","text":"Remembers input/output of a function in a jsonl file on disk. Parameters: Name Type Description Default filepath str path to write data to required from memo import memfile @memfile ( filepath = \"tmpfile.jsonl\" ) def simulate ( a , b ): return { \"result\" : a + b } for a in range ( 5 ): for b in range ( 10 ): simulate ( a = a , b = b ) Source code in memo/_base.py def memfile ( filepath : str ): \"\"\" Remembers input/output of a function in a jsonl file on disk. Arguments: filepath: path to write data to ```python from memo import memfile @memfile(filepath=\"tmpfile.jsonl\") def simulate(a, b): return {\"result\": a + b} for a in range(5): for b in range(10): simulate(a=a, b=b) ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) with open ( filepath , \"a\" ) as f : ser = orjson . dumps ( { ** kwargs , ** result }, option = orjson . OPT_NAIVE_UTC | orjson . OPT_SERIALIZE_NUMPY , ) f . write ( ser . decode ( \"utf-8\" ) + \" \\n \" ) return result return wrapper return decorator","title":"memfile()"},{"location":"api.html#memo._base.memfunc","text":"Remembers input/output of a function by printing. Parameters: Name Type Description Default callback Callable callback function that receives a dictionary with logged info required from memo import memfunc , memlist data = [] @memlist ( data = data ) @memfunc ( callback = print ) def simulate ( a , b ): return { \"result\" : a + b } for a in range ( 5 ): for b in range ( 10 ): simulate ( a = a , b = b ) # You should now see print statements, and this holds: assert len ( data ) == 50 Source code in memo/_base.py def memfunc ( callback : Callable ): \"\"\" Remembers input/output of a function by printing. Arguments: callback: callback function that receives a dictionary with logged info ```python from memo import memfunc, memlist data = [] @memlist(data=data) @memfunc(callback=print) def simulate(a, b): return {\"result\": a + b} for a in range(5): for b in range(10): simulate(a=a, b=b) # You should now see print statements, and this holds: assert len(data) == 50 ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) callback ({ ** kwargs , ** result }) return result return wrapper return decorator","title":"memfunc()"},{"location":"api.html#memo._http.memweb","text":"Remembers input/output of a function by sending it over http to an endpoint. Important Note that this decorator requires an extra dependeny. Ensure it is installed properly by running either; python -m pip install \"memo[web]\" You can also install it by installing all optional dependencies. python -m pip install \"memo[all]\" Parameters: Name Type Description Default url str web url to post json to required Source code in memo/_http.py def memweb ( url : str ): \"\"\" Remembers input/output of a function by sending it over http to an endpoint. Important: Note that this decorator requires an extra dependeny. Ensure it is installed properly by running either; ``` python -m pip install \"memo[web]\" ``` You can also install it by installing all optional dependencies. ``` python -m pip install \"memo[all]\" ``` Arguments: url: web url to post json to \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): result = func ( * args , ** kwargs ) with httpx . Client () as client : _ = client . post ( url , data = { ** kwargs , ** result }) return result return wrapper return decorator","title":"memweb()"},{"location":"faq.html","text":"Do I really need to output a dictionary? \u00b6 It's an opinionated packages but we thinkg it's neater that way. You'll usually want to have a name attached to column names in a dataframe and functions can have multiple outputs. Can I add a progress bar? \u00b6 You get a progress bar when you're using our internal grid method. Demo \u00b6 import numpy as np from memo import memlist , memfile , grid , time_taken data = [] @memfile ( filepath = \"results.jsonl\" ) @memlist ( data = data ) @time_taken () def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } for setting in grid ( class_size = range ( 20 , 30 ), n_sim = [ 100 , 10_000 , 1_000_000 ]): birthday_experiment ( ** setting ) Note that you can turn the progress bar off via grid(progbar=False, ...) . Can I get amazing visualisations? \u00b6 Sure, but they won't be supplied by this package. Instead we might recommend checking out hiplot . It gives a pretty parallel coordinates from jupyter notebook. If you've got a list with dictionaries you can run; import hiplot as hip data = [{ 'dropout' : 0.1 , 'lr' : 0.001 , 'loss' : 10.0 , 'optimizer' : 'SGD' }, { 'dropout' : 0.15 , 'lr' : 0.01 , 'loss' : 3.5 , 'optimizer' : 'Adam' }, { 'dropout' : 0.3 , 'lr' : 0.1 , 'loss' : 4.5 , 'optimizer' : 'Adam' }] hip . Experiment . from_iterable ( data ) . display () You can read in a file locally as well. import pandas as pd import hiplot as hip df = pd . read_json ( \"collected-data.jsonl\" , lines = True ) data = df . to_dict ( orient = 'records' ) hip . Experiment . from_iterable ( data ) . display ()","title":"FAQ"},{"location":"faq.html#do-i-really-need-to-output-a-dictionary","text":"It's an opinionated packages but we thinkg it's neater that way. You'll usually want to have a name attached to column names in a dataframe and functions can have multiple outputs.","title":"Do I really need to output a dictionary?"},{"location":"faq.html#can-i-add-a-progress-bar","text":"You get a progress bar when you're using our internal grid method.","title":"Can I add a progress bar?"},{"location":"faq.html#demo","text":"import numpy as np from memo import memlist , memfile , grid , time_taken data = [] @memfile ( filepath = \"results.jsonl\" ) @memlist ( data = data ) @time_taken () def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } for setting in grid ( class_size = range ( 20 , 30 ), n_sim = [ 100 , 10_000 , 1_000_000 ]): birthday_experiment ( ** setting ) Note that you can turn the progress bar off via grid(progbar=False, ...) .","title":"Demo"},{"location":"faq.html#can-i-get-amazing-visualisations","text":"Sure, but they won't be supplied by this package. Instead we might recommend checking out hiplot . It gives a pretty parallel coordinates from jupyter notebook. If you've got a list with dictionaries you can run; import hiplot as hip data = [{ 'dropout' : 0.1 , 'lr' : 0.001 , 'loss' : 10.0 , 'optimizer' : 'SGD' }, { 'dropout' : 0.15 , 'lr' : 0.01 , 'loss' : 3.5 , 'optimizer' : 'Adam' }, { 'dropout' : 0.3 , 'lr' : 0.1 , 'loss' : 4.5 , 'optimizer' : 'Adam' }] hip . Experiment . from_iterable ( data ) . display () You can read in a file locally as well. import pandas as pd import hiplot as hip df = pd . read_json ( \"collected-data.jsonl\" , lines = True ) data = df . to_dict ( orient = 'records' ) hip . Experiment . from_iterable ( data ) . display ()","title":"Can I get amazing visualisations?"},{"location":"getting-started.html","text":"Base Scenario \u00b6 Let's say you're running a simulation, or maybe a machine learning experiment. Then you might have code that looks like this; import numpy as np def birthday_experiment ( class_size , n_sim = 10_000 ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 return np . mean ( n_uniq != class_size ) results = [ birthday_experiment ( s ) for s in range ( 2 , 40 )] This example sort of works, but how would we now go about plotting our results? If you want to plot the effect of class_size and the simulated probability then it'd be do-able. But things get tricky if you're also interested in seeing the effect of n_sim as well. The input of the simulation isn't nicely captured together with the output of the simulation. Decorators \u00b6 The idea behind this library is that you can rewrite this function, only slightly, to make all of this data collection a whole log simpler. import numpy as np from memo import memlist data = [] @memlist ( data = data ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 return { \"est_proba\" : np . mean ( n_uniq != class_size )} for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim ) The data object now represents a list of dictionaries that have \"n_sim\" , \"class_size\" and \"est_proba\" as keys. You can easily turn these into a pandas DataFrame if you'd like via pd.DataFrame(data) . Logging More \u00b6 The memlist decorate takes care of all data collection. It captures all keyword arguments of the function as well as the dictionary output of the function. This then is appended this to a list data . Especially when you're iteration on your experiments this might turn out to be a lovely pattern. For example, suppose we also want to log how long the simulation takes; import time import numpy as np from memo import memlist data = [] @memlist ( data = data ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" t1 = time . time () sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) t2 = time . time () return { \"est_proba\" : proba , \"time\" : t2 - t1 } for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim ) Power \u00b6 The real power of the library is that you can choose not only to log to a list. You can just as easily write to a file too! import time import numpy as np from memo import memlist , memfile data = [] @memfile ( filepath = \"results.json\" ) @memlist ( data = data ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" t1 = time . time () sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) t2 = time . time () return { \"est_proba\" : proba , \"time\" : t2 - t1 } for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim ) Utilities \u00b6 The library also offers utilities to make the creation of these grids even easier. In particular; We supply a grid generation mechanism to prevent a lot of for-loops. We supply a @capture_time so that you don't need to write that logic yourself. import numpy as np from memo import memlist , memfile , grid , time_taken data = [] @memfile ( filepath = \"results.json\" ) @memlist ( data = data ) @time_taken () def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } for settings in grid ( class_size = range ( 2 , 40 ), n_sim = [ 1000 , 10000 , 100000 ]): birthday_experiment ( ** settings ) More features \u00b6 These decorators aren't performing magic, but my experience has been that these decorators make it more fun to actually log the results of experiments. It's nice to be able to just add a decorator to a function and not have to worry about logging the statistics. The library also offers extra features to make things a whole log simpler. memlists sends the json blobs to a list memfile sends the json blobs to a file memweb sends the json blobs to a server via http-post requests memfunc sends the data to a callable that you supply, like print grid generates a convenient grid for your experiments random_grid generates a randomized grid for your experiments time_taken also logs the time the function takes to run Check out the API docs to explore these in more detail.","title":"Getting Started"},{"location":"getting-started.html#base-scenario","text":"Let's say you're running a simulation, or maybe a machine learning experiment. Then you might have code that looks like this; import numpy as np def birthday_experiment ( class_size , n_sim = 10_000 ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 return np . mean ( n_uniq != class_size ) results = [ birthday_experiment ( s ) for s in range ( 2 , 40 )] This example sort of works, but how would we now go about plotting our results? If you want to plot the effect of class_size and the simulated probability then it'd be do-able. But things get tricky if you're also interested in seeing the effect of n_sim as well. The input of the simulation isn't nicely captured together with the output of the simulation.","title":"Base Scenario"},{"location":"getting-started.html#decorators","text":"The idea behind this library is that you can rewrite this function, only slightly, to make all of this data collection a whole log simpler. import numpy as np from memo import memlist data = [] @memlist ( data = data ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 return { \"est_proba\" : np . mean ( n_uniq != class_size )} for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim ) The data object now represents a list of dictionaries that have \"n_sim\" , \"class_size\" and \"est_proba\" as keys. You can easily turn these into a pandas DataFrame if you'd like via pd.DataFrame(data) .","title":"Decorators"},{"location":"getting-started.html#logging-more","text":"The memlist decorate takes care of all data collection. It captures all keyword arguments of the function as well as the dictionary output of the function. This then is appended this to a list data . Especially when you're iteration on your experiments this might turn out to be a lovely pattern. For example, suppose we also want to log how long the simulation takes; import time import numpy as np from memo import memlist data = [] @memlist ( data = data ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" t1 = time . time () sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) t2 = time . time () return { \"est_proba\" : proba , \"time\" : t2 - t1 } for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim )","title":"Logging More"},{"location":"getting-started.html#power","text":"The real power of the library is that you can choose not only to log to a list. You can just as easily write to a file too! import time import numpy as np from memo import memlist , memfile data = [] @memfile ( filepath = \"results.json\" ) @memlist ( data = data ) def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" t1 = time . time () sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) t2 = time . time () return { \"est_proba\" : proba , \"time\" : t2 - t1 } for size in range ( 2 , 40 ): for n_sim in [ 1000 , 10000 , 100000 ]: birthday_experiment ( class_size = size , n_sim = n_sim )","title":"Power"},{"location":"getting-started.html#utilities","text":"The library also offers utilities to make the creation of these grids even easier. In particular; We supply a grid generation mechanism to prevent a lot of for-loops. We supply a @capture_time so that you don't need to write that logic yourself. import numpy as np from memo import memlist , memfile , grid , time_taken data = [] @memfile ( filepath = \"results.json\" ) @memlist ( data = data ) @time_taken () def birthday_experiment ( class_size , n_sim ): \"\"\"Simulates the birthday paradox. Vectorized = Fast!\"\"\" sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } for settings in grid ( class_size = range ( 2 , 40 ), n_sim = [ 1000 , 10000 , 100000 ]): birthday_experiment ( ** settings )","title":"Utilities"},{"location":"getting-started.html#more-features","text":"These decorators aren't performing magic, but my experience has been that these decorators make it more fun to actually log the results of experiments. It's nice to be able to just add a decorator to a function and not have to worry about logging the statistics. The library also offers extra features to make things a whole log simpler. memlists sends the json blobs to a list memfile sends the json blobs to a file memweb sends the json blobs to a server via http-post requests memfunc sends the data to a callable that you supply, like print grid generates a convenient grid for your experiments random_grid generates a randomized grid for your experiments time_taken also logs the time the function takes to run Check out the API docs to explore these in more detail.","title":"More features"},{"location":"util.html","text":"Utility Methods \u00b6 grid ( progbar = True , ** kwargs ) \u00b6 Generates a grid of settings. Parameters: Name Type Description Default kwargs the name of parameter is the key while the values represent items to iterate over {} Example from memo import grid settings = list ( grid ( a = [ 1 , 2 ], b = [ 1 , 2 ])) expected = [ { 'a' : 1 , 'b' : 1 }, { 'a' : 1 , 'b' : 2 }, { 'a' : 2 , 'b' : 1 }, { 'a' : 2 , 'b' : 2 } ] assert settings == expected def calc_sum ( a , b ): return { \"c\" : a + b } for setting in settings : print ( calc_sum ( ** setting )) Source code in memo/_grid.py def grid ( progbar = True , ** kwargs ): \"\"\" Generates a grid of settings. Arguments: kwargs: the name of parameter is the key while the values represent items to iterate over Example ```python from memo import grid settings = list(grid(a=[1,2], b=[1, 2])) expected = [ {'a': 1, 'b': 1}, {'a': 1, 'b': 2}, {'a': 2, 'b': 1}, {'a': 2, 'b': 2} ] assert settings == expected def calc_sum(a, b): return {\"c\": a + b} for setting in settings: print(calc_sum(**setting)) ``` \"\"\" settings = list ( it . product ( * [ v for v in kwargs . values ()])) if progbar : for s in track ( settings , description = \"Grid...\" ): yield { k : v for k , v in zip ( kwargs . keys (), s )} else : for s in settings : yield { k : v for k , v in zip ( kwargs . keys (), s )} random_grid ( progbar = True , n = 30 , ** kwargs ) \u00b6 Generates a random grid settings. Parameters: Name Type Description Default kwargs the name of parameter is the key while the values represent items to iterate over {} Example from memo import random_grid settings = list ( random_grid ( n = 30 , a = [ 1 , 2 ], b = [ 1 , 2 ])) assert len ( settings ) == 30 Source code in memo/_grid.py def random_grid ( progbar = True , n = 30 , ** kwargs ): \"\"\" Generates a random grid settings. Arguments: kwargs: the name of parameter is the key while the values represent items to iterate over Example ```python from memo import random_grid settings = list(random_grid(n=30, a=[1,2], b=[1, 2])) assert len(settings) == 30 ``` \"\"\" if progbar : for _ in track ( range ( n ), description = \"Random Grid...\" ): yield { k : random . choice ( v ) for k , v in kwargs . items ()} else : for _ in range ( n ): yield { k : random . choice ( v ) for k , v in kwargs . items ()} time_taken ( minutes = False , rounding = 2 ) \u00b6 Adds additional time-based information to output. Parameters: Name Type Description Default minutes log minutes instead of seconds False rounding number of decimals to round the timing to 2 Examples: import numpy as np from memo import memlist , grid , time_taken data = [] @memlist ( data = data ) @time_taken () def birthday_experiment ( class_size , n_sim ): sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } settings = grid ( class_size = range ( 5 , 50 ), n_sim = [ 100 , 10_000 , 1_000_000 ]) for setting in settings : birthday_experiment ( ** setting ) Source code in memo/_util.py def time_taken ( minutes = False , rounding = 2 ): \"\"\" Adds additional time-based information to output. Arguments: minutes: log minutes instead of seconds rounding: number of decimals to round the timing to Example: ```python import numpy as np from memo import memlist, grid, time_taken data = [] @memlist(data=data) @time_taken() def birthday_experiment(class_size, n_sim): sims = np.random.randint(1, 365 + 1, (n_sim, class_size)) sort_sims = np.sort(sims, axis=1) n_uniq = (sort_sims[:, 1:] != sort_sims[:, :-1]).sum(axis = 1) + 1 proba = np.mean(n_uniq != class_size) return {\"est_proba\": proba} settings = grid(class_size=range(5, 50), n_sim=[100, 10_000, 1_000_000]) for setting in settings: birthday_experiment(**setting) ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): tic = time . time () result = func ( * args , ** kwargs ) toc = time . time () time_total = toc - tic if minutes : time_total = time_total / 60 result = { ** result , \"time_taken\" : round ( time_total , rounding )} return result return wrapper return decorator","title":"Utility"},{"location":"util.html#utility-methods","text":"","title":"Utility Methods"},{"location":"util.html#memo._grid.grid","text":"Generates a grid of settings. Parameters: Name Type Description Default kwargs the name of parameter is the key while the values represent items to iterate over {} Example from memo import grid settings = list ( grid ( a = [ 1 , 2 ], b = [ 1 , 2 ])) expected = [ { 'a' : 1 , 'b' : 1 }, { 'a' : 1 , 'b' : 2 }, { 'a' : 2 , 'b' : 1 }, { 'a' : 2 , 'b' : 2 } ] assert settings == expected def calc_sum ( a , b ): return { \"c\" : a + b } for setting in settings : print ( calc_sum ( ** setting )) Source code in memo/_grid.py def grid ( progbar = True , ** kwargs ): \"\"\" Generates a grid of settings. Arguments: kwargs: the name of parameter is the key while the values represent items to iterate over Example ```python from memo import grid settings = list(grid(a=[1,2], b=[1, 2])) expected = [ {'a': 1, 'b': 1}, {'a': 1, 'b': 2}, {'a': 2, 'b': 1}, {'a': 2, 'b': 2} ] assert settings == expected def calc_sum(a, b): return {\"c\": a + b} for setting in settings: print(calc_sum(**setting)) ``` \"\"\" settings = list ( it . product ( * [ v for v in kwargs . values ()])) if progbar : for s in track ( settings , description = \"Grid...\" ): yield { k : v for k , v in zip ( kwargs . keys (), s )} else : for s in settings : yield { k : v for k , v in zip ( kwargs . keys (), s )}","title":"grid()"},{"location":"util.html#memo._grid.random_grid","text":"Generates a random grid settings. Parameters: Name Type Description Default kwargs the name of parameter is the key while the values represent items to iterate over {} Example from memo import random_grid settings = list ( random_grid ( n = 30 , a = [ 1 , 2 ], b = [ 1 , 2 ])) assert len ( settings ) == 30 Source code in memo/_grid.py def random_grid ( progbar = True , n = 30 , ** kwargs ): \"\"\" Generates a random grid settings. Arguments: kwargs: the name of parameter is the key while the values represent items to iterate over Example ```python from memo import random_grid settings = list(random_grid(n=30, a=[1,2], b=[1, 2])) assert len(settings) == 30 ``` \"\"\" if progbar : for _ in track ( range ( n ), description = \"Random Grid...\" ): yield { k : random . choice ( v ) for k , v in kwargs . items ()} else : for _ in range ( n ): yield { k : random . choice ( v ) for k , v in kwargs . items ()}","title":"random_grid()"},{"location":"util.html#memo._util.time_taken","text":"Adds additional time-based information to output. Parameters: Name Type Description Default minutes log minutes instead of seconds False rounding number of decimals to round the timing to 2 Examples: import numpy as np from memo import memlist , grid , time_taken data = [] @memlist ( data = data ) @time_taken () def birthday_experiment ( class_size , n_sim ): sims = np . random . randint ( 1 , 365 + 1 , ( n_sim , class_size )) sort_sims = np . sort ( sims , axis = 1 ) n_uniq = ( sort_sims [:, 1 :] != sort_sims [:, : - 1 ]) . sum ( axis = 1 ) + 1 proba = np . mean ( n_uniq != class_size ) return { \"est_proba\" : proba } settings = grid ( class_size = range ( 5 , 50 ), n_sim = [ 100 , 10_000 , 1_000_000 ]) for setting in settings : birthday_experiment ( ** setting ) Source code in memo/_util.py def time_taken ( minutes = False , rounding = 2 ): \"\"\" Adds additional time-based information to output. Arguments: minutes: log minutes instead of seconds rounding: number of decimals to round the timing to Example: ```python import numpy as np from memo import memlist, grid, time_taken data = [] @memlist(data=data) @time_taken() def birthday_experiment(class_size, n_sim): sims = np.random.randint(1, 365 + 1, (n_sim, class_size)) sort_sims = np.sort(sims, axis=1) n_uniq = (sort_sims[:, 1:] != sort_sims[:, :-1]).sum(axis = 1) + 1 proba = np.mean(n_uniq != class_size) return {\"est_proba\": proba} settings = grid(class_size=range(5, 50), n_sim=[100, 10_000, 1_000_000]) for setting in settings: birthday_experiment(**setting) ``` \"\"\" def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): tic = time . time () result = func ( * args , ** kwargs ) toc = time . time () time_total = toc - tic if minutes : time_total = time_total / 60 result = { ** result , \"time_taken\" : round ( time_total , rounding )} return result return wrapper return decorator","title":"time_taken()"}]}